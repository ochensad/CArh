\section{Ход выполнения работы}

Все задания лабораторной работы выполнялись по варианту 10.

\subsection{Задание 1}

В листинге~\ref{lst1} представлен код программы по индивидуальному варианту. На рисунке~\ref{img:1.jpg} представлен дизассемблированный код программы. А в листинге~\ref{lst2} представлен псевдокод программы по индивидуальному варианту на языке С.

\begin{lstlisting}[caption={Код программы по индивидуальному варианту}, label=lst1, style=Go]
.section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
		add x31, x0, x0
lp:
        lw x2, 0(x1)
        lw x3, 4(x1) #!
        add x31, x31, x2
        add x31, x31, x3
        lw x4, 8(x1)
        lw x5, 12(x1)
        add x31, x31, x4
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
\end{lstlisting}

\img{1\textwidth}{1.jpg}{Дизассемблированный код программы}

\begin{lstlisting}[caption={Псевдокод на языке Си}, label=lst2, style=Go]
#define len 8
#define enroll 4
#define elem_sz 4

int _x[] = {1, 2, 3, 4, 5, 6, 7, 8};

void start()
{
	int x20 = len/enroll;
	int *x1 = _x;
	int x31 += 0;
	
	do
	{
		int x2 = x1[0];
		int x3 = x1[4];
		x31 += x2;
		x31 += x3;
		int x4 = x1[8];
		int x5 = x1[12];
		x31 += x4;
		x31 += x5;
		x1 += elem_sz*enroll;
		int x20 -= 1;
	}
	while (x20 != 0);
	x31 += 1;
	
	while (1) {};
}
\end{lstlisting}


После выполнения программы в $x31$ будет содержаться сумма всех элементов массива + 1. Или $\sum_{0}^{7} x[i] + 1 = 37$.

\subsection{Задание 2}

В результате симуляции был получен снимок экрана, содержащий временную диаграмму выполнения стадий выборки и диспетчеризации команды с адресом 8000000c (1-я итерация). Результат представлен на рисунке~\ref{img:task_2.jpg}.

\img{0.4\textwidth}{task_2.jpg}{Временная диаграмма выполнения стадий выборки и диспетчеризации команды с адресом 80000030 (1-я итерация)}

В такте 14 fetch\_complete = 1, следовательно, в предыдущем такте произошла выборка команды 80000030. 

%На такте 13 $pc = 80000030$. Этот адрес, соответствующий данному значению, а именно 200000с выставляется на шину адреса

\subsection{Задание 3}

В результате симуляции был получен снимок экрана, содержащий временную диаграмму выполнения стадий декодирования и планирования команды с адресом 80000010 (2-я итерация). Результат представлен на рисунке~\ref{img:task_3.jpg}.

\img{0.55\textwidth}{task_3.jpg}{Временная диаграмма выполнения стадий декодирования и планирования команды с адресом 80000010}

На 24 такте декодируется команда 80000010 с id=0. На 25 такте планируется ее выполнение. 

\subsection{Задание 4}

В результате симуляции был получен снимок экрана, содержащий временную диаграмму выполнения стадии выполнения команды с адресом 80000024. Результат представлен на рисунке~\ref{img:task_4.jpg}.

\img{0.55\textwidth}{task_4.jpg}{Временная диаграмма выполнения стадии выполнения команды с адресом 80000024}

Так как команда 80000024 -- команда доступа к памяти, то ее выполнение занимает 3 такта. Она начнет выполняться в 14 такте и закончит в 16 такте.

\subsection{Задание 5}

В данном задании симуляция происходит на программе из задания 1. 

Для проверки сравним теоретические значение с значением, полученным с помощью симуляции. На рисунке~\ref{img:result.png} представлен результат из симуляции. Он равен $0x25_{16} = 37_{10}$. Теоретическое значение сошлось с действительным.

\img{0.55\textwidth}{result.png}{Результат работы программы в симуляции}

В тексте программы~\ref{lst1} символом \#! обозначена команда \texttt{lw x3, 4(x1)}. Из дизассемблированного кода, приведенного на рисунке~\ref{img:1.jpg}, можно увидеть, что эта команда имеет адрес 80000014. На рисунках~\ref{img:task5-1.jpg} --~\ref{img:task5-2.jpg} можно увидеть временные диаграммы сигналов, соответствующих всем стадиям выполнения этой команды. 

\img{0.6\textwidth}{task5-1.jpg}{Временные диаграммы выполнения стадий выборки и диспетчеризации}
\img{0.6\textwidth}{task5-2.jpg}{Временные диаграммы выполнения стадий декодирования и планирования}
\img{0.5\textwidth}{task5-3.jpg}{Временная диаграмма выполнения стадии выполения}

В 8 такте происходит декодирование команды. В 9 такте -- ее планирование. С 9 такта по 11 программа выполнялась.
Наглядно порядок выполнения стадий конвейера процесса можно увидеть на трассе выполнения программы, представленной на~\ref{img:pipline.png}.

\img{0.5\textwidth}{pipline.png}{Трасса выполнения программы}

\newpage
Из трассы видно, что конфликты происходят из-за того, что пока данные загружаются в память, уже готова к выполнению операция сложения с этими данными. Оптимизировать программу можно следующим путем: пока в память загружаются данные, производить вычислительные операции не связанные с этими данными. В результате можно будет уменьшить программу на 4 такта или на $4/49 = 8\%$.

Код оптимизированной программы представлен на листинге~\ref{lst3}, дизассемблированный код -- на рисунке~\ref{img:2.jpg}, псевдокод -- в листинге~\ref{lst4}.

\begin{lstlisting}[caption={Код оптимизированной программы по индивидуальному варианту}, label=lst3, style=Go]
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        lw x3, 4(x1) #!
        lw x4, 8(x1)
        lw x5, 12(x1)
        add x31, x31, x2
        add x31, x31, x3
        add x31, x31, x4
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
\end{lstlisting}


\img{0.6\textwidth}{2.jpg}{Дизассемблированный код оптимизированной программы}

\begin{lstlisting}[caption={Псевдокод оптимизировнной программы на языке Си}, label=lst4, style=Go]
#define len 8
#define enroll 4
#define elem_sz 4

int _x[] = {1, 2, 3, 4, 5, 6, 7, 8};

void start()
{
	int x20 = len/enroll;
	int *x1 = _x;
	int x31 += 0;
	
	do
	{
		int x2 = x1[0];
		int x3 = x1[4];
		int x4 = x1[8];
		int x5 = x1[12];
		x31 += x2;
		x31 += x3;
		x31 += x4;
		x31 += x5;
		x1 += elem_sz*enroll;
		int x20 -= 1;
	}
	while (x20 != 0);
	x31 += 1;
	
	while (1) {};
}
\end{lstlisting}

Теперь трасса выполнения программы, представленная на рисунке~\ref{img:piplineOpt.png}, выглядит следующим образом.

\img{0.5\textwidth}{piplineOpt.png}{Трасса выполнения оптимизированной программы}
\newpage